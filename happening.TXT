#include <glad/glad.h>
#include <GLFW/glfw3.h>
#include <iostream>
#include <glut/glut.h>

void framebuffer_size_callback(GLFWwindow* window, int width, int height);
void processInput(GLFWwindow* window);
int mode = 2;
// settings
const unsigned int SCR_WIDTH = 1000;
const unsigned int SCR_HEIGHT = 1000;
const int SUCCESS_THRESHOLD = 15000;
void error_callback(int error, const char* description) {
    fprintf(stderr, "Error: %s\n", description);
}

// Function to handle key events
void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods) {
    if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS) {
        glfwSetWindowShouldClose(window, GLFW_TRUE);
    }
}

GLuint compileShaders() {
    const char* vertexShaderSource = R"(
        #version 330 core
        layout (location = 0) in vec3 aPos;
        uniform mat4 model;
        void main() {
            gl_Position = model * vec4(aPos, 1.0);
        }
    )";

    const char* fragmentShaderSource = R"(
        #version 330 core
        out vec4 FragColor;
        uniform vec3 color;
        void main() {
            FragColor = vec4(color, 1.0);
        }
    )";

    // Compile Vertex Shader
    GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vertexShader, 1, &vertexShaderSource, NULL);
    glCompileShader(vertexShader);

    // Compile Fragment Shader
    GLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL);
    glCompileShader(fragmentShader);

    // Link shaders
    GLuint shaderProgram = glCreateProgram();
    glAttachShader(shaderProgram, vertexShader);
    glAttachShader(shaderProgram, fragmentShader);
    glLinkProgram(shaderProgram);

    // Delete the shaders as they're linked into our program now and no longer necessary
    glDeleteShader(vertexShader);
    glDeleteShader(fragmentShader);

    return shaderProgram;
}

int isPointInPentagon(float x, float y) {
    float vertices[] = {
        0.0f,  0.5f, 0.0f, // Top
        -0.5f, 0.15f, 0.0f, // Top left
        -0.3f, -0.5f, 0.0f, // Bottom left
        0.3f, -0.5f, 0.0f,  // Bottom right
        0.5f, 0.15f, 0.0f   // Top right
    };

    int i, j, c = 0;
    int n = sizeof(vertices) / sizeof(vertices[0]) / 3;

    for (i = 0, j = n - 1; i < n; j = i++) {
        if (((vertices[3 * i + 1] > y) != (vertices[3 * j + 1] > y)) &&
            (x < (vertices[3 * j] - vertices[3 * i]) * (y - vertices[3 * i + 1]) / (vertices[3 * j + 1] - vertices[3 * i + 1]) + vertices[3 * i])) {
            c = !c;
        }
    }

    return c;
}

void findPoint(float qx, float qy, float vx, float vy, float& px, float& py) {
    px = (((1.0f / 3.0f) * qx) + ((2.0f / 3.0f) * vx));
    py = (((1.0f / 3.0f) * qy) + ((2.0f / 3.0f) * vy));

    //px = (2.0 * qx + vx) / 3.0;
    //py = (2.0 * qy + vy) / 3.0;
}

int show(GLfloat points[][3], int n) {
    GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, "OpenGL", NULL, NULL);
    if (window == NULL)
    {
        std::cout << "Failed to create GLFW window" << std::endl;
        glfwTerminate();
        return -1;
    }
    glfwMakeContextCurrent(window);
    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);
    glfwSetKeyCallback(window, key_callback);

    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
    {
        std::cout << "Failed to initialize GLAD" << std::endl;
        return -1;
    }

    GLfloat vertices[5][3] = {
        {0.0f,  0.5f, 0.0f}, // Top
        {-0.5f, 0.15f, 0.0f}, // Top left
        {-0.3f, -0.5f, 0.0f}, // Bottom left
        {0.3f, -0.5f, 0.0f},  // Bottom right
        {0.5f, 0.15f, 0.0f}   // Top right
    };
    // Compile shaders
    GLuint shaderProgram = compileShaders();



    // Calculating q
    srand(time(NULL));
    float qx = (float)rand() / (float)RAND_MAX - 0.5; // Random x coordinate between -0.5 and 0.5
    float qy = (float)rand() / (float)RAND_MAX - 0.5; // Random y coordinate between -0.5 and 0.5
    // Ensure the generated point is inside the pentagon, if not regenerate
    while (!isPointInPentagon(qx, qy)) {

        qx = (float)rand() / (float)RAND_MAX - 0.5;
        qy = (float)rand() / (float)RAND_MAX - 0.5;
    }
    int successCount = 0;
    while (successCount < n) {
        // Find point 1/3 of the distance between q and a randomly selected vertex
        int randomVertexIndex = rand() % 5; // Randomly select a vertex index (0 to 4)
        GLfloat vx = vertices[randomVertexIndex][0];
        GLfloat vy = vertices[randomVertexIndex][1];
        GLfloat px, py;
        findPoint(qx, qy, vx, vy, px, py);

        points[successCount][0] = px;
        points[successCount][1] = py;
        points[successCount][2] = 0.0f;
        qx = px;
        qy = py;
        successCount++;
    }

    // Set up vertex buffer object (VBO) and vertex array object (VAO)
    GLuint VBO, VAO;
    glGenVertexArrays(1, &VAO);
    glGenBuffers(1, &VBO);

    glBindVertexArray(VAO);

    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBufferData(GL_ARRAY_BUFFER, 3 * n * sizeof(GLfloat), points, GL_STATIC_DRAW);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (GLvoid*)0);
    glEnableVertexAttribArray(0);

    glBindBuffer(GL_ARRAY_BUFFER, 0);
    glBindVertexArray(0);

    // render loop
    // -----------
    while (!glfwWindowShouldClose(window)) {
        // Render here
        glClear(GL_COLOR_BUFFER_BIT);

        // Use the compiled shader program
        glUseProgram(shaderProgram);

        // Set uniform values
        GLint modelLoc = glGetUniformLocation(shaderProgram, "model");
        GLint colorLoc = glGetUniformLocation(shaderProgram, "color");

        GLfloat model[] = {
            1.0f, 0.0f, 0.0f, 0.0f,
            0.0f, 1.0f, 0.0f, 0.0f,
            0.0f, 0.0f, 1.0f, 0.0f,
            0.0f, 0.0f, 0.0f, 1.0f
        };
        glUniformMatrix4fv(modelLoc, 1, GL_FALSE, model);
        glUniform3f(colorLoc, 1.0f, 0.0f, 0.0f); // Set color to red

        // Draw all points
        glBindVertexArray(VAO);
        glDrawArrays(GL_POINTS, 0, SUCCESS_THRESHOLD);
        glBindVertexArray(0);

        // Swap front and back buffers
        glfwSwapBuffers(window);

        // Poll for and process events
        glfwPollEvents();
    }

    // Cleanup
    free(points);
    glDeleteVertexArrays(1, &VAO);
    glDeleteBuffers(1, &VBO);
    glDeleteProgram(shaderProgram);

    glfwDestroyWindow(window);
    glfwTerminate();
}

int main()
{
    // Set the error callback
    glfwSetErrorCallback(error_callback);
    // glfw: initialize and configure
    // ------------------------------
    if (!glfwInit()) {
        fprintf(stderr, "Failed to initialize GLFW\n");
        return -1;
    }
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

#ifdef __APPLE__
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
#endif

    GLfloat points[15000][3];

    show(points, 15000);
    return 0;
}

// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly
// ---------------------------------------------------------------------------------------------------------
void processInput(GLFWwindow* window)
{
    if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
        glfwSetWindowShouldClose(window, true);
}

// glfw: whenever the window size changed (by OS or user resize) this callback function executes
// ---------------------------------------------------------------------------------------------
void framebuffer_size_callback(GLFWwindow* window, int width, int height)
{
    // make sure the viewport matches the new window dimensions; note that width and 
    // height will be significantly larger than specified on retina displays.
    glViewport(0, 0, width, height);
}